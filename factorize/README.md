# Factorize

This is an issue where the `n` value is formed from two consecutive primes. Even though the number is long, it is easily factorized. We used [this tool](https://www.alpertron.com.ar/ECM.HTM), which works almost instantly on consecutive primes.

## Primes

So the two primes work out to the following:

`152103631606164757991388657189704366976433537820099034648874538500153362765519668135545276650144504533686483692163171569868971464706026329525740394016509185464641520736454955410019736330026303289754303711165526821866422766844554206047678337249535003432035470125187072461808523973483360158652600992259609986591`

and

`152103631606164757991388657189704366976433537820099034648874538500153362765519668135545276650144504533686483692163171569868971464706026329525740394016509191077550351496973264159350455849525747355370985161471258126994336297660442739951587911017897809328177973473427538782352524239389465259173507406981248869793`

Notice the first digits are very similar.

## Decrypting

From [this StackExchange conversation](https://security.stackexchange.com/questions/25631/crack-plain-rsa-given-p-q-and-e) we learn the following:

```
n = pq
φ = (p-1)(q-1)
d = (1/e) mod φ
```

(The last line meaning Modular Inverse)

Those are calculated easily enough, with Python 3.8+ having a built in Modular Inverse function.

```python
phi = (p-1) * (q-1)
d = pow(e, -1, phi)
```

From there we can decrypt the encoded number:

```python
pti = pow(c, d, n)
```

Which we then convert decode from `int` to `string`:

```python
import codecs
pti = pow(c, d, n)
pt = codecs.decode(hex(pti)[2:],'hex').decode()
```

(`c` is the encrypted starting string, `pti` is the plain text integer, and `pt` is the plain text)

Then we get the flag: `flag{just_g0tta_f@ct0rize_1t4536}`

## Final Code

```python
import codecs

def decrypt(p, q, e, c):
 n = p*q
 phi = (p-1) * (q-1)
 d = pow(e, -1, phi)
 pti = pow(c, d, n)
 return codecs.decode(hex(pti)[2:],'hex').decode()

# consecutive prime vulnerability
p = 152103631606164757991388657189704366976433537820099034648874538500153362765519668135545276650144504533686483692163171569868971464706026329525740394016509185464641520736454955410019736330026303289754303711165526821866422766844554206047678337249535003432035470125187072461808523973483360158652600992259609986591
q = 152103631606164757991388657189704366976433537820099034648874538500153362765519668135545276650144504533686483692163171569868971464706026329525740394016509191077550351496973264159350455849525747355370985161471258126994336297660442739951587911017897809328177973473427538782352524239389465259173507406981248869793

e = 0x10001

c = 17830167351685057470426148820703481112309475954806278304600862043185650439097181747043204885329525211579732614665322698426329449125482709124139851522121862053345527979419420678255168453521857375994190985370640433256068675028575470040533677286141917358212661540266638008376296359267047685745805295747215450691069703625474047825597597912415099008745060616375313170031232301933185011013735135370715444443319033139774851324477224585336813629117088332254309481591751292335835747491446904471032096338134760865724230819823010046719914443703839473237372520085899409816981311851296947867647723573368447922606495085341947385255

print(decrypt(p,q,e,c))
```